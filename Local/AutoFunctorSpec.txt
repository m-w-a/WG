WG_AUTOFUNCTOR_TYPE(name)
  Expands to the implementation dependent type of the autofunctor named "name".

Purpose:
  1) A tool for conveying and enforcing the intent of block scopes.
    Some Background: 
    Block scopes
    are used in C++ to enforce temporal constrains on automatic variables or to
    partition code into logical units. Commented block scopes certainly do 
    convey the intent of such logical units of code, but at times it's desirable
    to also convey and enforce how these units interact with their enclosing 
    scope. Autofunctor allows the programmer to do that with top most declarations
    documenting and enforcing what and how enclosing scope(s) variables are 
    accessed.
  2) Many times local functions are only needed to be called once, yet this is 
    often forgotten by programmers. With autofunctor, there is no need to call
    the local function after it has been defined since it's auto-called.

//----------
//Semantics:
//----------

assignto:
  1) if obj type is qualified const then a compiler error will result.
    Rationale:
    It's impossible to assign to an object of a const qualified type.
  2) obj type ref qualification is redundant.
    Rationale:
    The assignee should always be captured by reference, else no assignment 
    would take place.

return:
  1) If present then indicates the return type of the functor,
  2) else if not present and assignto is present then the return type of the
    functor is determined by the type of assignto declaration,
  3) else if not present and assignto is not present then the return type of the
    functor is void.

parambind:
  1) parameters that are auto-passed to the functor when and only when
     it's auto-called.
  2) For more info see bound-variables section.

paramset:
  1) parameters that are auto-passed to the functor when and only when
     it's auto-called.
  2) For more info see set-variables section.

membind:
memset:
  1) Member variables of the functor.
  2) For more info see bound-variables and set-variables sections.

bound-variables:
  1) Variables whose values are bound to variables of the same name from 
    the enclosing scope(s).
  2) If implicitly typed, the types of such variables are determined by the
    type of the variables they are bound to via BOOST_TYPEOF. Hence, this will
    always be remove_reference<remove_const<type-of-boundee>::type>::type.
    (*) Therefore, if you want something bound by reference always use the ref
    keyword and if you want something bound by const always use the const 
    keyword.
  3) If explicitly typed, the types of such variables must be "implicitly
    convertible to" from the type of the variable that they respectively bind in
    their outer scope.

set-variables:
  1) Variables whose values are determined by user specified expressions.
  2) If implicitly typed, the types of such variables are determined by the
    type of the expression they are set to via BOOST_TYPEOF. Such an expression 
    may contain identifiers from the enclosing scope(s). If such an 
    expression is a variable, then the caveats of b-v 2) apply.

ppescape(()):
  NOTE: the use of double parenthesis is required!
  Rationale:
  The preprocessor uses the comma token to delimit macro parameters. If a type
  that had an embedded comma, such as std::pair<int, long>, appeared in a macro
  parameter list it would be interpreted as two parameters to that macro, 
  namely "std::pair<ing" and "long>". Thus it's impossible to directly use 
  such types as macro parameters if we wish to strictly stay C++03 conformant, 
  since variadic macros are not part of the that standard.

local():
  Rationale:
  bound vars need to be forwarded to their destination via a temporary cntnr,
  for purposes of efficiency this is done using the add_reference metafunction. 
  Since in C++03 local types have no linkage, they cannot be used as template 
  parameters, and therefore cannot be used with metafunctions. 
  Hence, the need to bind such types differently.
  
  The local keyword is to be used to wrap non-const non-reference local types.  
  Any use contrary to such will result in a compiler error. Such wrapped types
  may then be qualified via the keywords const, ref, or const ref as demonstrated
  in the BNF section.
  
  IMPL detail: in C++11 treat such types as regular types for the purposes of 
    codegen? (TODO.)

this_:
  1) If encountered as a bound variable name, then it will bind to the "this" 
    keyword.
  ---------
  Note: -->
  ---------
  2) If encountered as a bound variable and implicitly typed and explicitly
    qualified with the keyword const, then the constness will apply to the
    pointed-to-type.
    Rationale:
      The type of "this", and hence the type of "this_", is already const. 
      Therefore the const keyword would be redundant if applied to the "outer 
      type". The above semantics are provided as an alternative shortcut 
      to explicitly typing "this_" and const qualifying the pointed-to-type.

//---
//BNF
//---

special symbols:
  [...] specifies an optional BNF expression.
terminals : assignto return parambind paramset membind memset const ref ppescape

autofunctor-usage := 
  autofunctor-start-macro ( autofunctor-spec ) 
  cv-qualifier-seq exception-specification
  function-body
  WG_AUTOFUNCTOR_END [;]

autofunctor-start-macro :=
    WG_AUTOFUNCTOR
  | WG_AUTOFUNCTOR_TPL

autofunctor-spec :=
    void
  | [assignto assignto-tuple]
    [return return-tuple]
    [parambind parambind-seq]
    [paramset paramset-seq]
    [membind membind-seq]
    [memset memset-seq]

assignto-tuple := bound-tuple

return-tuple := 
    ( non-local-type-with-no-embedded-commas )
  | ( ppescape(( non-local-type-unrestricted-syntax )) )
  | ( local-type )

parambind-seq := bound-tuple-seq
paramset-seq := set-tuple-seq
membind-seq := bound-tuple-seq
memset-seq := set-tuple-seq

bound-tuple-seq :=
    bound-tuple
  | bound-tuple-seq bound-tuple

set-tuple-seq :=
    set-tuple
  | set-tuple-seq set-tuple

bound-tuple :=
  ( bound-var-dcln )

set-tuple :=
  ( set-var-dcln )

bound-var-dcln := type-var-dcln

set-var-dcln := type-var-dcln , value-expr

type-var-dcln := 
    implicit-type-var-dcln
  | explicit-type-var-dcln

implicit-type-var-dcln :=
  implicit-type var-name

explicit-type-var-dcln :=
  explicit-type var-name

implicit-type := lib-type-qualifiers | empty-string

lib-type-qualifiers := const | ref | const ref

explicit-type :=
    non-local-type 
  | local-type

non-local-type := 
    ( non-local-type-with-no-embedded-commas )
  | ppescape(( non-local-type-unrestricted-syntax ))

local-type :=
    local(local-nonconst-nonref-type)
  | local(local-nonconst-nonref-type) lib-type-qualifiers

cv-qualifier-seq := See C++ standard.
exception-specification := See C++ standard.
function-body := See C++ standard.
type := A C++ type.
var-name := A C++ variable name.
local-nonconst-nonref-type := 
  A C++ type declaration specifying a non-const, non-reference local type.
non-local-type-with-no-embedded-commas := 
  A C++ type declaration specifying a non-local type that contains no commas.
non-local-type-unrestricted-syntax := 
  A C++ type declaration specifying a non-local type.
value-expr := A C++ expression evaluating to some value.