AutoFunction
------------

x) empty macros
x) WG_PP_TOKENS_STARTS_WITH_THISU -> replace thisu?
x) AUTOFUNCTION_BIND
x) AUTOFUNCTION_ASSIGN
x) AUTOFUNCTION
x) local/localref
x) result
x) return types
x) recursive
x) swap tokens in pp_seq
WG_PP_TOKENS_STARTS_WITH_ASSIGNTO -> autofunction
x) TokenMatchings.hh
x) Make actual unit tests for pp.
x) AUTOFUNCTION -> AUTOFUNCTOR
x) TOKENS_STARTS_WITH_ -> TOKENS_STARTWITH_

x) comment pseq
x) document WG_PP_MAKE_PSEQ_IMPL1
add token autofunction in autofunction macros
granularize pp includes ??
x) IIF instead of IF
Type.hh -> ParsedTypeToCppType.hh


optimize IIF -> by splitting branches
UnitTests : Explicit -> Implicit where possible.
add membind/memset support
finish pp unit tests.
  do SetVarDclnNormalize.hh - do compile time array comparisons exist?
x) automate running of pp unit tests.
allow implicit typing in paramset.

Better Error Message Reporting:
  ASSERT_MSG
  below
Better Syntax Error Checking:
  empty spec
  missing type in explicit-typed-var-dcln
  missing var in "..."
  missing type in implicit-typed-var-dcln
  missing var in "..."

Better Test Names:
  AssignTo
  Return
  ParamBindExplicit
  ParamBindImplicit
  ParamBindImplicitAndExplicit
  ParamSetExplicit
  ParamSetImplicit
  ParamSetImplicitAndExplicit
  ParamBindExplicitAndParamSetExplicit
  ParamBindImplicitAndParamSetImplicit
  ParamBindExplicitAndParamSetImplicit
  ParamBindImplicitAndParamSetExplicit

Then go over And make sure test coverage right.

//----------
//Semantics:
//----------

assignto:
  1) If not typed with localref then it will always be implicitly bound by
    reference. 
    Rationale:
    1) Doing otherwise will result in assignment to a copy of the variable,
      instead of the actual variable itself.
    2) If typed with localref, then it is assumed that the bound type is already
      a reference, hence no need to implicitly bind it by reference.
  2) If implicitly typed, then it's illegal for it to be const or ref qualified.
    Rationale:
    1) const qualification does not make sense, since we want to eventually 
      assign to the assignto variable.
    2) ref qualification is redundant, per 1.1

return:
  1) If present then indicates the return type of the functor,
  2) else if not present and assignto is present then the return type of the
    functor is determined by the type of assignto declaration,
  3) else if not present and assignto is not present then the return type of the
    functor is void.

local()
  Rationale:
  bound vars need to be forwarded to their destination via a temporary cntnr,
  for purposes of efficiency this is done using the add_reference metafunction. 
  Since in C++03 local types have no linkage, they cannot be used as template 
  parameters, and therefore cannot be used with metafunctions. 
  Hence, the need to bind such types differently.
  
  The local keyword is to be used to wrap non-const non-reference local types.  
  Any use contrary to such will result in a compiler error. Such wrapped types
  may then be qualified via the keywords const, ref, or const ref as demonstrated
  in the BNF section.
  
  IMPL detail: in C++11 treat such types as regular types for the purposes of codegen?

//---
//BNF
//---

special symbols:
  [...] specifies an optional BNF expression.
terminals : assignto return parambind paramset membind memset const ref

autofunction-spec :=
    void
  | [assignto assignto-tuple]
    [return return-tuple]
    [parambind parambind-seq]
    [paramset paramset-seq]
    [membind membind-seq]
    [memset memset-seq]

assignto-tuple := (assignto-dcln)

return-tuple := 
    (non-local-type)
  | (local-type)

parambind-seq := bound-tuple-seq
paramset-seq := set-tuple-seq
membind-seq := bound-tuple-seq
memset-seq := set-tuple-seq

bound-tuple-seq :=
    bound-tuple
  | bound-tuple-seq bound-tuple

set-tuple-seq :=
    set-tuple
  | set-tuple-seq set-tuple

bound-tuple :=
  ( bound-var-dcln )

set-tuple :=
  ( set-var-dcln )

assignto-dcln := 
     var-name
  |  explicit-typed-var-dcln

bound-var-dcln :=
    implicit-typed-var-dcln
  | explicit-typed-var-dcln

set-var-dcln :=
  explicit-typed-var-dcln , value-expr

implicit-typed-var-dcln :=
  implicit-type var-name

explicit-typed-var-dcln :=
  explicit-type var-name

implicit-type := lib-type-qualifiers | empty-string

lib-type-qualifiers := const | ref | const ref

explicit-type := 
    local-type
  | ( non-local-type )

local-type :=
    local(local-nonconst-nonref-type)
  | local(local-nonconst-nonref-type) lib-type-qualifiers

type := A C++ type.
var-name := A C++ variable name.
local-nonconst-nonref-type := 
  A C++ type declaration specifying a non-const, non-reference local type.
non-local-type := A C++ type declaration specifying a non-local type.
value-expr := A C++ expression evaluating to some value.