WG_LCLFUNCTION_TYPE(name)
  Expands to the implementation dependent type of the object named "name".

Differences w/Boost.LocalFunction
  x) This library allows the function name to be specified at and only at the 
    top of the local function declaration, unlike Boost::LocalFunction.
  x) This library allows local functions to maintain internal state without 
    referencing external variables (via varset), unlike Boost::LocalFunction.
  x) This library uses a different syntax.
  x) This library does not have default parameters, unlike Boost::LocalFunction. 
    In the author's view it adds too little expressivity to be worth the effort  
    to implement.
  x) This library has a much cleaner implementation. 
    1) The preprocessor translator is partitioned into a front end and 
      back end. 
    2) A well-defined symbol table bridging the two translation layers.
    3) A well-defined error-generating mechanism with a seperate error pass
      before code generation. 

Limitations: 
  1) In C++03 may not be usable across library boundaries since local types lack
    linkage. Hence, the necessary symbols may not be exported.
  2) Local function bodies are in fact local class method bodies, so any language
    limitations that apply the latter also apply to the former.

Standard Type Names
  Withing the local function body, the following typenames are available:
    result_type
    arg1_type
    arg2_type
    etc...

Boost::Function
  Local function objects maybe assigned to ::boost::function objects. The const
  qualification of such ::boost::function objects will not affect how the local
  function object is called. This to allow the following use case:
    struct signaler
    {
      typedef ::boost::function<void()> callback_type;
      
      explicit signaler(callback_type const & callback)
      : m_callback(callback)
      {}
      
      ~explicit()
      {
        m_callback();
      }
      
      callback_type const m_callback;
    };
    
    void listen()
    {
      bool didCall = false;
      WG_LCLFUNCTION(lstnr, varbind (ref didcall) )
      {
        didCall = true;
      }WG_LCLFUNCTION_END;
      
      {
        signaler s(lstnr);
      }
      
      BOOST_TEST(didCall == true);
    }
    
  Clearly the intent of const qualifying signaler::m_callback is to prevent 
  reassignment after ctor initialization, not to prevent lstnr from being
  called because it captured "didcall" by non-const reference.

//----------
//Semantics:
//----------

Note: All terms not defined here should be referenced in AutoFunctorSpec.txt

return:
  1) If present then indicates the return type of the function,
  2) else if not present then the return type of the function is void.

param-seq:
  1) Limit: min(WG_PP_LCLFUNCTION_CONFIG_PARAMS_MAX_ARITY, BOOST_PP_LIMIT_REPEAT)
    Currently, WG_PP_LCLFUNCTION_CONFIG_PARAMS_MAX_ARITY is set to 15

varbind:
  1) See function-variables.
  2) See bound-variables.
varset:
  1) See function-variables.
  2) See set-variables.
  3) The order in which variables are set is undefined.
    Rationale:
      This is because these variables are initialized from some function 
      parameter values and in C++ the order of parameter value evaluation in a
      function call is unspecified.

function-variables:
  Variables that are local to each function instance. Note that each call of the 
  same local function instance gets the same function variables. So, if a function 
  variables' state is changed for a given function instance, that change will 
  be reflected in the next call of the *same* function instance.
  Naming Rationale: 
    Said variables are not necessarily implemented as member variables of a  
    function instance. It is an implementation detail what form they take. 
    Hence, that's why they're specified with var* keywords and mem* keywords.

//---
//BNF
//---

special symbols:
  [...] specifies an optional BNF expression.
terminals: return params varbind varset const ref

lclfunction-usage :=
  lclfunction-start-macro ( name , lclfunction-spec )
  function-body
  WG_LCLFUNCTION_END [;]

lclfunction-start-macro := 
    WG_LCLFUNCTION
  | WG_LCLFUNCTION_TPL

lclfunction-spec :=
    void
  | [return nlt-return-tuple]
    [params param-seq]
    [varbind varbind-seq]
    [varset varset-seq]

nlt-return-tuple :=
    ( non-local-type-with-no-embedded-commas )

param-seq :=
    param-tuple
  | param-seq param-tuple

varbind-seq := nlt-bound-tuple-seq
varset-seq := nlt-set-tuple-seq

param-tuple :=
  (explicit-non-local-type-var-dcln)

nlt-bound-tuple-seq :=
    nlt-bound-tuple
  | nlt-bound-tuple-seq nlt-bound-tuple

nlt-set-tuple-seq :=
    nlt-set-tuple
  | nlt-set-tuple-seq nlt-set-tuple

nlt-bound-tuple :=
  ( nlt-bound-var-dcln )

nlt-set-tuple :=
  ( nlt-set-var-dcln )

nlt-bound-var-dcln := nlt-type-var-dcln

nlt-set-var-dcln := nlt-type-var-dcln , value-expr

nlt-type-var-dcln :=
    implicit-non-local-type-var-dcln
  | explicit-non-local-type-var-dcln

implicit-non-local-type-var-dcln :=
  implicit-type-var-dcln

explicit-non-local-type-var-dcln :=
  explicit-non-local-type var-name
