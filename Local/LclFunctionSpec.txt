WG_LCLFUNCTION_TYPE(name)
  Expands to the implementation dependent type of the object named "name".
  
Note: All terms not defined here should be referenced in AutoFunctorSpec.txt

Limitations: 
  In C++03 may not be usable across library boundaries since local types lack
  linkage. Hence, the necessary symbols may not be exported.

Boost::Function
  Local function objects maybe assigned to boost::function objects. The const
  qualification of such boost::function objects will not affect how the local
  function object is called. This to allow the following use case:
    struct signaler
    {
      typedef boost::function<void()> callback_type;
      
      explicit signaler(callback_type const & callback)
      : m_callback(callback)
      {}
      
      ~explicit()
      {
        m_callback();
      }
      
      callback_type const m_callback;
    };
    
    void listen()
    {
      bool didCall = false;
      WG_LCLFUNCTION(lstnr, varbind (ref didcall) )
      {
        didCall = true;
      }WG_LCLFUNCTION_END;
      
      {
        signaler s(lstnr);
      }
      
      BOOST_TEST(didCall == true);
    }
    
  Clearly the intent of const qualifying signaler::m_callback is to prevent 
  reassignment after ctor initialization, not to prevent lstnr from being
  called because it captured didcall by non-const reference.

//----------
//Semantics:
//----------
  
return:
  1) If present then indicates the return type of the function,
  2) else if not present then the return type of the function is void.

param-seq:
  1) Limit: min(WG_PP_LCLFUNCTION_MAX_ARGS, BOOST_PP_LIMIT_REPEAT)
    Currently, WG_PP_LCLFUNCTION_MAX_ARGS is set to 15

varbind:
varspec:
  Captures variables in the enclosing scope(s). Note that each call of the 
  same local function object gets the same capturing object. So, if a capturing 
  object's state is changed for a given local function object, that change will 
  be reflected in the next call of the *same* local function object.

//---
//BNF
//---

//Note:
//  1) params needs to be PP parseable because it needs to be prepended/appended
//    to in codegen for the purpose of constructing the callback signature.

special symbols:
  [...] specifies an optional BNF expression.
terminals : return params varbind varset const ref

lclfunction-usage :=
  lclfunction-start-macro ( lclfunction-spec )
  function-body
  WG_LCLFUNCTION_END [;]

lclfunction-start-macro := 
    WG_LCLFUNCTION
  | WG_LCLFUNCTION_TPL

lclfunction-spec :=
    void
  | [return nlt-return-tuple]
    [params param-seq]
    [varbind varbind-seq]
    [varset varset-seq]

nlt-return-tuple :=
    ( non-local-type-with-no-embedded-commas )
  | ( ppescape(( non-local-type-unrestricted-syntax )) )

param-seq :=
    param-tuple
  | param-seq param-tuple

varbind-seq := nlt-bound-tuple-seq
varset-seq := nlt-set-tuple-seq

param-tuple :=
  (non-local-type var-name)

nlt-bound-tuple-seq :=
    nlt-bound-tuple
  | nlt-bound-tuple-seq nlt-bound-tuple

nlt-set-tuple-seq :=
    nlt-set-tuple
  | nlt-set-tuple-seq nlt-set-tuple

nlt-bound-tuple :=
  ( nlt-bound-var-dcln )

nlt-set-tuple :=
  ( nlt-set-var-dcln )

nlt-bound-var-dcln := nlt-type-var-dcln

nlt-set-var-dcln := nlt-type-var-dcln , value-expr

nlt-type-var-dcln :=
    implicit-type-var-dcln
  | nlt-explicit-type-var-dcln

nlt-explicit-type-var-dcln :=
  nlt-explicit-type var-name

nlt-explicit-type := non-local-type
