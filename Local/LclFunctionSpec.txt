WG_LCLFUNCTION_TYPE(name)
  Expands to the implementation dependent type of the object named "name".

Differences w/Boost.LocalFunction
  x) This library allows the function name to be specified at and only at the 
    top of the local function declaration, unlike Boost::LocalFunction.
  x) This library allows local functions to maintain internal state without 
    referencing external variables (via varset), unlike Boost::LocalFunction.
  x) This library uses a different syntax.
  x) This library does not have default parameters, unlike Boost::LocalFunction. 
    In the author's view it adds too little expressivity to be worth the effort  
    to implement.
  x) This library has a much cleaner implementation. 
    1) The preprocessor translator is partitioned into a front end and 
      back end. 
    2) A well-defined symbol table bridging the two translation layers.
    3) A well-defined error-generating mechanism with a seperate error pass
      before code generation. 

Limitations: 
  1) In C++03 may not be usable across library boundaries since local types lack
    linkage. Hence, the necessary symbols may not be exported.
  2) Local function bodies are in fact local class method bodies, so any language
    limitations that apply the latter also apply to the former.

Standard Type Names
  Withing the local function body, the following typenames are available:
    result_type
    arg1_type
    arg2_type
    etc...

Boost::Function
  Local function objects maybe assigned to boost::function objects. The const
  qualification of such boost::function objects will not affect how the local
  function object is called. This to allow the following use case:
    struct signaler
    {
      typedef boost::function<void()> callback_type;
      
      explicit signaler(callback_type const & callback)
      : m_callback(callback)
      {}
      
      ~explicit()
      {
        m_callback();
      }
      
      callback_type const m_callback;
    };
    
    void listen()
    {
      bool didCall = false;
      WG_LCLFUNCTION(lstnr, varbind (ref didcall) )
      {
        didCall = true;
      }WG_LCLFUNCTION_END;
      
      {
        signaler s(lstnr);
      }
      
      BOOST_TEST(didCall == true);
    }
    
  Clearly the intent of const qualifying signaler::m_callback is to prevent 
  reassignment after ctor initialization, not to prevent lstnr from being
  called because it captured "didcall" by non-const reference.

//----------
//Semantics:
//----------

Note: All terms not defined here should be referenced in AutoFunctorSpec.txt

return:
  1) If present then indicates the return type of the function,
  2) else if not present then the return type of the function is void.

param-seq:
  1) Limit: min(WG_PP_LCLFUNCTION_MAX_ARGS, BOOST_PP_LIMIT_REPEAT)
    Currently, WG_PP_LCLFUNCTION_MAX_ARGS is set to 15

varbind:
  1) See captured-variables.
  2) See bound-variables.
varset:
  1) See captured-variables.
  2) See set-variables.
  3) The order in which variables are set is undefined.

captured-variables:
  Captures variables in the enclosing scope(s). Note that each call of the 
  same local function object gets the same capturing object. So, if a capturing 
  object's state is changed for a given local function object, that change will 
  be reflected in the next call of the *same* local function object.

//---
//BNF
//---

//Note:
//  1) params needs to be PP parseable because it needs to be prepended/appended
//    to in codegen for the purpose of constructing the callback signature.

special symbols:
  [...] specifies an optional BNF expression.
terminals: return params varbind varset const ref

lclfunction-usage :=
  lclfunction-start-macro ( name , lclfunction-spec )
  function-body
  WG_LCLFUNCTION_END [;]

lclfunction-start-macro := 
    WG_LCLFUNCTION
  | WG_LCLFUNCTION_TPL

lclfunction-spec :=
    void
  | [return nlt-return-tuple]
    [params param-seq]
    [varbind varbind-seq]
    [varset varset-seq]

nlt-return-tuple :=
    ( non-local-type-with-no-embedded-commas )
  | ( ppescape(( non-local-type-unrestricted-syntax )) )

param-seq :=
    param-tuple
  | param-seq param-tuple

varbind-seq := nlt-bound-tuple-seq
varset-seq := nlt-set-tuple-seq

param-tuple :=
  (non-local-type var-name)

nlt-bound-tuple-seq :=
    nlt-bound-tuple
  | nlt-bound-tuple-seq nlt-bound-tuple

nlt-set-tuple-seq :=
    nlt-set-tuple
  | nlt-set-tuple-seq nlt-set-tuple

nlt-bound-tuple :=
  ( nlt-bound-var-dcln )

nlt-set-tuple :=
  ( nlt-set-var-dcln )

nlt-bound-var-dcln := nlt-type-var-dcln

nlt-set-var-dcln := nlt-type-var-dcln , value-expr

nlt-type-var-dcln :=
    implicit-type-var-dcln
  | nlt-explicit-type-var-dcln

nlt-explicit-type-var-dcln :=
  nlt-explicit-type var-name

nlt-explicit-type := non-local-type
